### 垃圾回收

```js
var a = "before";
var b = "override a";
var a = b; //重写a
　//这段代码运行之后，“before”这个字符串失去了引用（之前是被a引用），系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用

//现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。
```

### 立即执行函数和使用场景

```js
<script>
		window.onload = function(){
			var box = document.getElementById('box');
			var divs = document.getElementsByTagName('span');
			for (var i = 0, len = divs.length; i < len; i++) { 
				// 为了获得不同的i值，使用立即调用函数
				(function(i){
					var text = divs[i].innerText;
					divs[i].onmouseover = function() {
						console.log('index is :' + text);
					}
				})(i);
			}
		}
	</script>


```

### 实现一个add方法，使计算结果能够满足如下预期：

```js

add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;

function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = Array.prototype.slice.call(arguments);

    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var _adder = function() {
        _args.push(...arguments);
        return _adder;
    };

    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
    _adder.toString = function () {
        return _args.reduce(function (a, b) {
            return a + b;
        });
    }
    return _adder;
}
```

