###  new操作符具体干了什么呢?

```js
const o = new Object();//创建了一个新的空对象o
o.__proto__ = Foo.prototype;//让这个o对象的` __proto__`指向函数的原型`prototype`
Foo.call(o);//this指向o对象
a = o;//将o对象赋给a对象
```

### 用过哪些设计模式？

```js
// 混合模式创建（构造+原型）
 window.onload = function () {
    //混合模式  构造函数+原型
    //构造函数写可变的属性和变量
    function  Student(name) {
        this.name = name;
        this.eat = 18;
    }
    //破坏了封装性
    Student.prototype.eat = function () {
        console.log("吃饭");
    };
    //实例对象
    var s1 = new Student("小明");
    var s2 = new Student("如花");
    console.log(s1.name,s2.name); //小明 如花
    console.log(s1.eat == s2.eat); //true;
}
//动态混合模式
 window.onload = function () {
    //混合模式  构造函数+原型
    //构造函数写可变的属性和变量
    function Student(name) {
        this.name = name;
        this.eat = 18;
        /*Student.prototype.eat = function () {
         console.log("吃饭");
         } 调试还是每创建一个对象就会执行一次，原型是只初始化一次的*/
        //判断是否存在，不存在则添加
        if (!(typeof this.eat == "function")) {
            Student.prototype.eat = function () {
                console.log("吃饭");
            }
        }
        //实例对象
        var s1 = new Student("小明");
        var s2 = new Student("如花");
        console.log(s1.name, s2.name); //小明 如花
        console.log(s1.eat == s2.eat); //true;
    }
}   
```

###  call()和apply()的区别和作用？

```js
function add(a,b){
  return a+b;  
}
function sub(a,b){
  return a-b;  
}
var a1 = add.apply(sub,[4,2]);　　//sub调用add的方法
var a2 = sub.apply(add,[4,2]);
alert(a1);  //6     
alert(a2);  //2

/*call的用法*/
var a1 = add.call(sub,4,2);

```

###  JavaScript对象的几种创建方式？

```js
//1、对象字面量的方式   

   person={firstname:"Mark",lastname:"Yun",age:25,eyecolor:"black"};


//2、用function来模拟无参的构造函数

   function Person(){}

   var person=new Person();//定义一个function，如果使用new"实例化",该function可以看作是一个Class

   person.name="Mark";

   person.age="25";

   person.work=function(){

       alert(person.name+" hello...");

    }

   person.work();

 

//3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）

   function Pet(name,age,hobby){

      this.name=name;//this作用域：当前对象

      this.age=age;

      this.hobby=hobby;

      this.eat=function(){

         alert("我叫"+this.name+",我喜欢"+this.hobby+",是个程序员");

      }

    }

   var maidou =new Pet("麦兜",25,"coding");//实例化、创建对象

   maidou.eat();//调用eat方法

 

/4、用工厂方式来创建（内置对象） 

    var wcDog =new Object();

    wcDog.name="旺财";

    wcDog.age=3;

    wcDog.work=function(){

      alert("我是"+wcDog.name+",汪汪汪......");

    }

    wcDog.work();

  

//5、用原型方式来创建 

   function Dog(){ }

    Dog.prototype.name="旺财";

    Dog.prototype.eat=function(){

    alert(this.name+"是个吃货");

    }

    var wangcai =new Dog();

    wangcai.eat();

 

//6、用混合方式来创建

   function Car(name,price){

     this.name=name;

     this.price=price;

    }

    Car.prototype.sell=function(){

      alert("我是"+this.name+"，我现在卖"+this.price+"万元");

     }

   var camry =new Car("凯美瑞",27);

camry.sell();
```

###  JavaScript对象的几种继承方式？

```js
//1、原型链继承
  function Person (name) {
            this.name = name;
        };

        Person.prototype.getName = function () {    //对原型进行扩展
            return this.name;
        };

        function Parent (age) {
            this.age = age;
        };

        Parent.prototype = new Person('老明');   //这一句是关键 //通过构造器函数创建出一个新对象，把老对象的东西都拿过来。

        Parent.prototype.getAge = function () {
            return this.age;
        };

//        Parent.prototype.getName = function () {   //可以重写从父类继承来的方法,会优先调用自己的。
//            console.log(222);
//        };

        var result = new Parent(22);
        console.log(result.getName());  //老明　　//调用了从Person原型中继承来的方法(继承到了当前对象的原型中)　　
        console.log(result.getAge());   //22 　　//调用了从Parent原型中扩展来的方法
        
       // 2、构造继承
 function Person (name) {
            this.name = name;
            this.friends = ['小李','小红'];
            this.getName = function () {
                return this.name;
            }
        };

//        Person.prototype.geSex = function () {    //对原型进行扩展的方法就无法复用了
//            console.log("男");
//        };

        function Parent = (age) {
            Person.call(this,'老明');　　//这一句是核心关键
            //这样就会在新parent对象上执行Person构造函数中定义的所有对象初始化代码，
            // 结果parent的每个实例都会具有自己的friends属性的副本
            this.age = age;
        };

        var result = new Parent(23);
        console.log(result.name);　　　　//老明
        console.log(result.friends);　　//["小李", "小红"]
　　　　 console.log(result.getName());　　//老明
　　　　 console.log(result.age);　　　　//23
　　　　 console.log(result.getSex());　　//这个会报错，调用不到父原型上面扩展的方法

//3、组合继承 

        function Person  (name) {
             this.name = name;
             this.friends = ['小李','小红'];
         };

         Person.prototype.getName = function () {
             return this.name;
         };

        function Parent (age) {
            Person.call(this,'老明');　　//这一步很关键
            this.age = age;
        };

        Parent.prototype = new Person('老明');　　//这一步也很关键
        var result = new Parent(24);
        console.log(result.name);　　　　//老明
        result.friends.push("小智");　　//
        console.log(result.friends);　　//['小李','小红','小智']
        console.log(result.getName());　　//老明
        console.log(result.age);　　　　//24

        var result1 = new Parent(25);   //通过借用构造函数都有自己的属性，通过原型享用公共的方法
        console.log(result1.name);　　//老明
        console.log(result1.friends);　　//['小李','小红']

//4、寄生组合继承

        function Person(name) {
            this.name = name;
            this.friends = ['小李','小红'];
        }

        Person.prototype.getName = function () {
            return this.name;
        };

        function Parent(age) {
            Person.call(this,"老明");
            this.age = age;
        }

        (function () {
            var Super = function () {};     // 创建一个没有实例方法的类
            Super.prototype = Person.prototype;
            Parent.prototype = new Super();     //将实例作为子类的原型
        })();

        var result = new Parent(23);
        console.log(result.name);
        console.log(result.friends);
        console.log(result.getName());
        console.log(result.age);
```

###  JavaScript原型，原型链 ？

```

```

###  如何判断一个对象是否属于某个类？

```
javascript中检测对象的类型的运算符有：typeof、constructor、instanceof

typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如："number"，"string"，"boolean"，"object"，"function"，"undefined"（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是"object"。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。


instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。


constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。


Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。
```

l 小贤有一条可爱的狗(Dog),它的叫声很好听(wow),每次看到主人的时候就会乖乖叫一声(yelp),从这段描述可以得到以下对象：                                                function Dog(){

this.wow = function(){

alert(‘wow’);

}

this.yelp = function(){

this.wow();

}

}

小芒和小贤一样原来也有一条可爱的狗，可是突然有一点疯了(MadDog),一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例形式用代码来实现。(继承，原型，setInterval)

```js

	function MadDog() { }
	MadDog.prototype = new Dog();
	MadDog.prototype.lunYelp = function () {
		var abc = this;
		setInterval(function () {
			abc.yelp();
		}, 500)
	}


	var maddog = new MadDog();
	maddog.lunYelp();
```

